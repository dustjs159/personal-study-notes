Web Server
=================================
## Summary
- Last Updated : 21.06.12 Sat    
- Updated by : 윤연선
-----------------------------------

# Web Server
   
<img width="541" alt="스크린샷 2021-05-27 오후 6 18 33" src="https://user-images.githubusercontent.com/57285121/119800669-f4f85300-bf17-11eb-8472-55fafe71d24d.png">
    
* 클라이언트의 요청(HTTP Request)을 받아 해당 요청에 대한 정보를 클라이언트에게 응답(HTTP Response)으로 반환해주는 서버

## 정적 컨텐츠
* 클라이언트의 요청에 항상 같은 내용을 보여주는 웹 페이지
* 개발자에 의해 사전에 미리 준비된 페이지
* HTML, CSS 등으로만 구성
* Ex) 어느 사용자가 접속을 해도 항상 같은 내용만 표시되는 회사소개 페이지

## 동적 컨텐츠
* 클라이언트의 요청에 따라 다른 내용을 보여주는 웹 페이지
* 미리 만들어진 웹 페이지가 아닌 클라이언트의 요청 시 만들어지는 웹 페이지
* Ex) 로그인 정보를 가져온 웹 페이지, 쇼핑몰 결제항목 등

# Web Server 종류

## Apache HTTP Server
* 리눅스 기반 무료 오픈소스 웹서버(누구나 사용 가능)
* 프로세스와 스레드 기반으로 클라이언트의 요청을 처리
* MPM(Multi Processing Module)방식으로 HTTP 요청을 처리
* 모듈이라는 개념으로 많은 기능을 덧붙일 수 있음
* 클라이언트의 요청이 있을 때 마다 프로세스 혹은 스레드를 생성하는 구조.
* OS의 JVM(Java Virtual Machine)을 통해 메모리를 관리함(메모리는 웹 서버 성능에 가장 큰 영향)   
> * 웹 서버 운영 시 JVM은 OS로부터 메모리를 할당받음   
> * JVM 메모리(Runtime Data Area)의 heap 영역에 프로세스를 생성   
* Tomcat, Node.js와 묶어서 Load Balancer, Proxy 설정 가능
* PreFork MPM(멀티 프로세스 + 단일 스레드)
   
<img width="263" alt="스크린샷 2021-06-03 오전 1 12 44" src="https://user-images.githubusercontent.com/57285121/120514995-cf33e800-c408-11eb-9813-07dcf2f5f2fd.png">
   
> * 미리 복수의 프로세스를 생성하여 클라이언트의 요청에 대비하는 멀티프로세스 방식   
> * 프로세스와 스레드가 1:1   
> * 프로세스간 메모리를 공유하지 않기 때문(메모리 공간이 독립)에 시스템 다운 시에도 안정적   
> * 메모리의 사용량이 상대적으로 많다는 단점   
> * 안정성이 우선이 되는 경우, 단일 요청의 크기가 큰 경우에 사용   
* Worker MPM(멀티 프로세스 + 멀티 스레드)
   
<img width="295" alt="스크린샷 2021-06-03 오전 1 11 53" src="https://user-images.githubusercontent.com/57285121/120514891-b6c3cd80-c408-11eb-8b6f-18de9855403e.png">
   
> * 프로세스 내에서 멀티 스레드로 처리하는 방식   
> * 메모리의 사용량이 상대적으로 적기 때문에 동시 사용자가 많은 사이트에 적합   
> * 스레드 간 메모리를 공유하기 때문에 시스템 다운 시 안정적이지 못함   
> * 요청 하나 하나의 크기가 작고 동시 접속자가 많은 경우에 사용   
* 프로세스가 blocking 상태일 경우 요청을 처리하지 못하고 처리 완료 시까지 대기함
* Keep Alive(접속대기)로 해결이 가능하지만 효율이 떨어짐
* Keep Alive On 상태에서는 KeepAliveTimeout 시간동안 연결을 끊지 않고 다음 요청을 기다림(다시 하나하나 연결을 생성하고 끊는 작업을 할 필요가 없음)
* Keep Alive를 통해 대량 접속 시 오히려 효율이 떨어질 수 있음
* Apache 옵션   
> * Timeout : 지정한 시간동안 클라이언트가 응답이 없을 경우 세션을 끊음
> * MaxKeepAliveRequests : 허용할 최대 요청 수 지정   
> * KeepAlive / KeepAliveTimeout : 클라이언트의 지속적인 연결 허용 여부 및 허용 시간 설정   

* 장점   
> * 모듈들을 활용해 서비스 확장이 수월   
> * 다른 프로그래밍 언어나 DBMS와도 호환이 좋기 때문에 확장하기가 수월   
> * WAS인 Tomcat과 연결 시 동적 컨텐츠도 제공이 가능   
* 단점   
> * 대량 접속 시 성능 저하 가능성이 있음   
> * 메모리의 사용이 증가하고 추가적인 프로세스와 스레드 생성비용에 추가적으로 자원이 소모됨   

## Nginx
* 경량화 웹 서버
* Evnet-Driven 구조로 동작. Event handler가 대기시간 없이 즉각적으로 작업을 처리
   
<img width="442" alt="스크린샷 2021-05-28 오전 3 05 27" src="https://user-images.githubusercontent.com/57285121/119875319-95bf3080-bf61-11eb-9df2-38fafae405fa.png">
   
* 고정된 프로세스 혹은 스레드만을 생성하여 사용하고 비동기 입출력 방식(non-blocking)으로 클라이언트의 요청을 처리
* 하나의 Master 프로세스와 다수의 Worker 프로세스로 구성되어 실행
   
<img width="685" alt="스크린샷 2021-05-28 오전 3 11 53" src="https://user-images.githubusercontent.com/57285121/119876079-7674d300-bf62-11eb-91aa-9ab4071faa51.png">
   
* Master 프로세스는 Worker 프로세스를 관리
* Worker 프로세스는 클라이언트의 모든 요청을 처리
* Load Balancer : HTTP Request 부하 분산 기능
   
<img width="374" alt="스크린샷 2021-06-02 오전 2 47 04" src="https://user-images.githubusercontent.com/57285121/120368260-d2699e00-c34c-11eb-95e9-f80ae9434472.png">
   
* Reverse Proxy : 내부 서버들을 숨김(보안성)
* Node.js와 묶어서 Load Balancer, Proxy 설정 가능
* 장점   
> * Apache에 비해 빠른 속도(우수한 성능)
> * 새로운 프로세스와 스레드를 생성하지 않기 때문에 추가적인 자원이 소모되지 않음(적은 자원으로도 효율적인 운영 가능)   
> * 비동기 입출력 방식(non-blocking)처리로 다수의 클라이언트의 요청을 효율적으로 처리할 수 있음   
* 단점   
> * 윈도우와 호환이 잘 되지 않음   
> * Apache에 비해 오픈소스가 적음   
* Nginx Use Case
> * 단일 스레드 방식의 Node.js와는 다르게 좀 더 많은 스레드를 생성해 요청을 처리 할 수 있기 때문에 하나가 고장나도 다른 스레드가 요청을 처리할 수 있음(고가용성)   
> * 내부 서버들의 보안이 필요할 경우 Reverse Proxy 기능을 통해 보안성 향상   

## Node.js
* 서버 사이드 애플리케이션 개발에 사용되는 소프트웨어
* 크롬의 V8(자바 스크립트 컴파일 엔진)을 기반으로 개발
* 자바 스크립트 언어를 통해 풀스택 개발이 가능
* 싱글 스레드 기반으로 클라이언트의 요청 처리   
* 비동기 입출력 방식(non-blocking)으로 요청 처리
* 이벤트 기반으로 요청 처리
   
<img width="958" alt="스크린샷 2021-06-02 오전 1 34 41" src="https://user-images.githubusercontent.com/57285121/120359512-b5c86880-c342-11eb-9b93-beae0b136798.png">
   
> * 클라이언트의 요청을 비동기 입출력 방식으로 처리하기 위해 이벤트가 발생하고, 서버에 전달   
> * 서버 내 고성능의 CPU를 통해 단일 스레드 기반으로 Event Loop가 이벤트 처리   
> * Event Loop가 처리를 완료하면 Callback을 호출하여 처리 완료를 알림   
* NPM(Node Package Manager)을 통해 많은 모듈들 사용 가능
* 장점   
> * 서버의 컴퓨터 자원을 적게 소모함   
> * 비동기 입출력 방식으로 클라이언트의 요청을 처리하기 때문에 다수의 클라이언트 요청도 빠르게 처리할 수 있음   
> * NPM을 통해 개발자가 직접 구현하기 복잡한 기능을 손쉽게 사용할 수 있음   
* 단점   
> * 단일 스레드 기반으로 요청을 처리하기 때문에 클라이언트의 요청이 무거운 경우에는 서버의 성능이 저하될 수 있음   
> * 로직이 복잡하게 구성되어 꼬리에 꼬리를 물게 되면 Callback hell이 발생할 수 있음   
* Node.js Use Case   
> * 간단한 로직으로 구성된 웹 서버   
> * 요청에 대해 빠른 응답시간을 요구하는 경우   
> * 스트리밍 서비스, 채팅 서비스 등   

## IIs(Internet Information Service)
* 웹 사이트, 서비스 및 응용 프로그램을 사용하기 위한 모듈식 플랫폼
* 윈도우 기반 웹 서버 소프트웨어
* 장점   
> * 간편한 GUI를 통해 쉽게 설치하고 사용이 가능   
* 단점   
> * OS 중 윈도우만 지원하기 때문에 다른 OS에서는 사용 불가   
> * 별도의 구매 비용이 비싸다는 단점
