운영체제
====================================
## Summary
- Last Updated : 21.10.08 Fri   
- Updated by : 윤연선
-----------------------------------

# 운영체제 
- OS(Operation System)
- 컴퓨터의 사용자와 하드웨어 사이에서 중개자 역할을 해주는 소프트웨어

# 운영체제의 목적
* 사용자가 컴퓨터를 편하게 사용하는 것(사용자 관점)
* 컴퓨터 하드웨어가 효율적으로 사용되는 것(시스템 관점)

# 컴퓨터 시스템의 처리 구조
   
<img width="240" alt="스크린샷 2021-05-22 오전 12 50 12" src="https://user-images.githubusercontent.com/57285121/119164732-acfcaa80-ba97-11eb-9a55-69dd7fbd63b1.png">
   
* 운영체제는 사용자와 하드웨어간 상호작용을 하며, 컴퓨터가 실행되는 동안에 항상 수행되는 프로그램
* 일반적인 사용자는 하드웨어를 직접 다루는 것은 불가능하지만 OS가 대신 이 부분을 수행해 주기 때문에 사용자는 편하게 하드웨어를 다룰 수 있음   

# 운영체제의 효율적인 하드웨어 사용
* CPU가 수행할 작업을 항상 언제든지 갖고 있도록 하는 방식
* CPU가 아무 일도 하지 않는 상태(Idle Time) 최소화

# 다중 프로그래밍(Multi-Programming)   
   
<img width="392" alt="스크린샷 2021-05-22 오전 1 34 20" src="https://user-images.githubusercontent.com/57285121/119170165-d6203980-ba9d-11eb-89a0-a320f33d241f.png">
   
1. 메인 메모리(RAM)에 적재되어 있는 작업 중 하나를 선택하여 수행   
2. 수행 중이던 첫 번째 작업이 사용자의 I/O을 기다리는 상태가 되면 CPU는 다른 작업으로 넘어가 다른 작업을 수행
3. 사용자의 I/O을 기다리던 첫 번째 작업이 사용자의 I/O을 받으면 CPU는 다른 작업들을 중단하고 다시 첫 번째 작업을 이어서 진행

# 시 분할 시스템 
   
<img width="446" alt="스크린샷 2021-05-26 오전 2 20 11" src="https://user-images.githubusercontent.com/57285121/119540890-e8b1b000-bdc8-11eb-9a71-4504fd8f7e11.png">
   
* 다중 프로그래밍의 확장 시스템
* 아주 짦은 주기로 CPU를 각각 프로그램에 할당하는 방법
* 프로그램이 수행되고 있는 동안에도 다른 프로그램과 상호작용 가능
* 사용자는 모든 프로그램이 동시에 실행되고 있다고 인지
* 작업 스케줄링 : 보조기억장치에 프로그램이 저장되어 있고 그 중 일부를 선택해서 메모리에 적재
* CPU 스케줄링 : 메모리에 올라온 작업들 중 어떤 작업을 먼저 수행할지 고르는 작업

# 컴퓨터 작동 과정
   
<img width="466" alt="스크린샷 2021-06-02 오후 8 59 39" src="https://user-images.githubusercontent.com/57285121/120476357-74d56000-c3e5-11eb-9d57-6231a7660395.png">
   
* CPU와 각 장치들은 서로 연결되어 매모리를 공유
* 각 장치마다 장치 제어기(Controller)가 작업을 도와줌

## 부팅 과정
1. 전원이 켜질 때 ROM에 저장된 초기 프로그램(부트 로더, Boot Loader)을 실행
2. 초기 프로그램은 메모리, CPU 등을 초기화 시킴
3. 메모리에 OS를 적재
4. OS는 첫 번째 프로세스를 즉시 실행
5. 인터럽트가 발생하며 CPU가 여러 작업들을 처리

# Kernel
* OS에서 가장 핵심적인 부분으로, 소프트웨어와 하드웨어 사이에서 인터페이스를 제공하여 응용 프로그램을 통한 하드웨어 자원(CPU, RAM, I/O장치 등)을 관리   

# Shell
* 사용자와 OS간 대화를 가능하게 해주는 명령어 해석기 역할
* 사용자가 명령어를 입력하면 Shell이 명령어를 해석하여 Kernel에 전송 및 수행결과를 받아와서 다시 사용자에게 보여줌

# OS의 종류
1. Windows   
- 개인용 PC에서 가장 많이 사용되고 있는 운영체제. GUI(Graphic User Interface)를 사용하기 때문에 명령어가 아닌 마우스, 키보드를 통해 조작이 쉽다는 장점이 있다

2. Linux
- 커널에 Linux커널을 사용. 자유-오픈소스 기반 OS이기 때문에 커널 소스를 받아서 직접 제작하여 사용
- 일반적으로 Linux배포판에 패키징 처리하여 배포됨
- 누구든지 Linux OS의 커널을 각자 용도에 맞게 개발하여 사용,수정,배포가 가능하다
- 공개 및 무료 OS이기 때문에 지속적인 유지보수가 용이함
- Windows보다 시스템 충돌이 덜 일어나기 때문에 시스템 구축에 있어서 보다 안정적임
- 기본적으로 요구되는 사양이 낮기 때문에 임베디드장치 등 한정적인 자원으로도 시스템 운영이 안정적
 -Windows보다 사용이 어렵고 숙련이 필요하다는 단점이 존재

3. UNIX
- 현대적 컴퓨터 운영체제 대부분의 근본으로써 C언어로 쓰여진 소프트웨어 개발용 운영체제
- 여러 시스템간 이식이 용이함

# OS 작업 방식
1. 멀티프로그래밍(Multi-Programming)
- 초기 컴퓨터는 CPU(프로세서) 하나당 하나의 프로그램(프로세스)만 처리가 가능했었다. 그런데 이 과정에서 CPU의 처리속도나 입/출력속도간 차이가 발생할 경우 입/출력이 완료될 때 까지 CPU는 idle time이 발생함. idle tiem은 프로세서의 자원낭비로 이어지는데 이것을 막기 위해 입/출력 작업 종료 대기를 하는 동안 하나의 프로세서에서 다른 작업을 진행할 수 있도록 하는 것
- idle time 최소화를 통한 CPU이용률 증가 목적
- 프로그램이 동시에 돌아가는 것 처럼 보여도 동시에 돌아가는 것이 아님

2. 멀티태스킹(Multi-Tasking)
- Task란 OS에서 처리하는 작업의 단위(프로세스 확장 개념)
- OS의 스케쥴링에 의해 이 Task가 번갈아 가며 수행됨
- 멀티프로그래밍이 프로세스 단위로 작업을 처리했다면, 멀티태스킹은 프로세스보다 확장된 개념인 Task단위로 OS의 스케쥴링 방식에 따라 작업을 처리

2-1. 선점형/비선점형 멀티태스킹 
- 선점형 멀티태스킹 : 응답없는 프로세스를 강제로 종료 가능    
- 비선점형 멀티태스킹 : 강제로 종료하지 못하고 시스템을 리셋해야함 

3. 멀티프로세싱(Mulit-Processing)
- 프로세스를 여러 개의 프로세스로 구성하여 다수의 프로세서가 프로세스를 병렬로 처리함
- 프로세서가 하나가 고장이 나도 시스템이 정지하는 것이 아니라 속도만 저하됨(신뢰성 향상)
- 프로세스들은 각각 독립된 메모리영역을 할당받기 때문에 서로 다른 프로세스간 메모리 접근 불가능(메모리 간 데이터 공유가 어렵다)

4.멀티쓰레딩(Multi Threading)
- 하나의 프로세스 내에서 둘 이상의 스레드(프로세스보다 작은 최소 실행 흐름 단위)가 동시에 작업을 수행
- 각 스레드가 자신이 속한 프로세스내의 stack영역을 제외한 메모리를 공유함(메모리 간 데이터 공유가 쉬움)
- 스레드 하나에 문제가 생기면 전체 프로세스에 영향을 끼치기 때문에 시스템 마비 등 결함 가능성 존재(신뢰성 낮음)
- 스레드 간 자원 공유 문제가 발생할 가능성이 있음
