운영체제(OS, Operation System)
====================================
Summary
- Last Updated : 21.05.22 Sat   
- Updated by : 윤연선
-----------------------------------

# 운영체제 : OS(Operation System)
* 컴퓨터의 사용자와 하드웨어 사이에서 중개자 역할을 해주는 프로그램

# 운영체제의 목적
* 사용자가 컴퓨터를 편하게 사용하는 것(사용자 관점)
* 컴퓨터 하드웨어가 효율적으로 사용되는 것(시스템 관점)

# 컴퓨터 시스템의 처리 구조
   
<img width="240" alt="스크린샷 2021-05-22 오전 12 50 12" src="https://user-images.githubusercontent.com/57285121/119164732-acfcaa80-ba97-11eb-9a55-69dd7fbd63b1.png">
   
* 운영체제는 사용자와 하드웨어간 상호작용을 하며, 컴퓨터가 실행되는 동안에 항상 수행되는 프로그램
* 일반적인 사용자는 하드웨어를 직접 다루는 것은 불가능하지만 OS가 대신 이 부분을 수행해 주기 때문에 사용자는 편하게 하드웨어를 다룰 수 있음   

# 운영체제의 효율적인 하드웨어 사용
* CPU가 수행할 작업을 항상 언제든지 갖고 있도록 하는 방식
* CPU가 아무 일도 하지 않는 상태(Idle Time) 최소화

## 다중 프로그래밍(Multi-Programming)   
   
<img width="392" alt="스크린샷 2021-05-22 오전 1 34 20" src="https://user-images.githubusercontent.com/57285121/119170165-d6203980-ba9d-11eb-89a0-a320f33d241f.png">
   
1. 메인 메모리(RAM)에 적재되어 있는 작업 중 하나를 선택하여 수행   
2. 수행 중이던 첫 번째 작업이 사용자의 I/O을 기다리는 상태가 되면 CPU는 다른 작업으로 넘어가 다른 작업을 수행
3. 사용자의 I/O을 기다리던 첫 번째 작업이 사용자의 I/O을 받으면 CPU는 다른 작업들을 중단하고 다시 첫 번째 작업을 이어서 진행

### Kernel & Shell
1. Kernel
> OS에서 가장 핵심적인 부분으로, 소프트웨어와 하드웨어 사이에서 인터페이스를 제공하여 응용 프로그램을 통한 하드웨어 자원(CPU, RAM, I/O장치 등)을 관리   
2. Shell
> 사용자와 OS간 대화를 가능하게 해주는 명령어 해석기 역할
> 사용자가 명령어를 입력하면 Shell이 명령어를 해석하여 Kernel에 전송 및 수행결과를 받아와서 다시 사용자에게 보여줌

### OS의 종류
1. Windows
> 개인용 PC에서 가장 많이 사용되고 있는 운영체제. GUI(Graphic User Interface)를 사용하기 때문에 명령어가 아닌 마우스, 키보드를 통해 조작이 쉽다는 장점이 있다
2. Linux
> 커널에 Linux커널을 사용. 자유-오픈소스 기반 OS이기 때문에 커널 소스를 받아서 직접 제작하여 사용
> 일반적으로 Linux배포판에 패키징 처리하여 배포됨
> 누구든지 Linux OS의 커널을 각자 용도에 맞게 개발하여 사용,수정,배포가 가능하다
> 공개 및 무료 OS이기 때문에 지속적인 유지보수가 용이함
> Windows보다 시스템 충돌이 덜 일어나기 때문에 시스템 구축에 있어서 보다 안정적임
> 기본적으로 요구되는 사양이 낮기 때문에 임베디드장치 등 한정적인 자원으로도 시스템 운영이 안정적
> Windows보다 사용이 어렵고 숙련이 필요하다는 단점이 존재
3. UNIX
> 현대적 컴퓨터 운영체제 대부분의 근본으로써 C언어로 쓰여진 소프트웨어 개발용 운영체제
> 여러 시스템간 이식이 용이함

### OS 작업 방식
1. 멀티프로그래밍(Multi-Programming)
> 초기 컴퓨터는 CPU(프로세서) 하나당 하나의 프로그램(프로세스)만 처리가 가능했었다. 그런데 이 과정에서 CPU의 처리속도나 입/출력속도간 차이가 발생할 경우 입/출력이 완료될 때 까지 CPU는 idle time이 발생함. idle tiem은 프로세서의 자원낭비로 이어지는데 이것을 막기 위해 입/출력 작업 종료 대기를 하는 동안 하나의 프로세서에서 다른 작업을 진행할 수 있도록 하는 것
> idle time 최소화를 통한 CPU이용률 증가 목적
> 프로그램이 동시에 돌아가는 것 처럼 보여도 동시에 돌아가는 것이 아님
2. 멀티태스킹(Multi-Tasking)
> Task란 OS에서 처리하는 작업의 단위(프로세스 확장 개념)
> OS의 스케쥴링에 의해 이 Task가 번갈아 가며 수행됨
> 멀티프로그래밍이 프로세스 단위로 작업을 처리했다면, 멀티태스킹은 프로세스보다 확장된 개념인 Task단위로 OS의 스케쥴링 방식에 따라 작업을 처리
>> #### 선점형/비선점형 멀티태스킹 
> 선점형 멀티태스킹 : 응답없는 프로세스를 강제로 종료 가능    
> 비선점형 멀티태스킹 : 강제로 종료하지 못하고 시스템을 리셋해야함 
3. 멀티프로세싱(Mulit-Processing)
> 프로세스를 여러 개의 프로세스로 구성하여 다수의 프로세서가 프로세스를 병렬로 처리함
> 프로세서가 하나가 고장이 나도 시스템이 정지하는 것이 아니라 속도만 저하됨(신뢰성 향상)
> 프로세스들은 각각 독립된 메모리영역을 할당받기 때문에 서로 다른 프로세스간 메모리 접근 불가능(메모리 간 데이터 공유가 어렵다)
4. 멀티쓰레딩(Multi Threading)
> 하나의 프로세스 내에서 둘 이상의 스레드(프로세스보다 작은 최소 실행 흐름 단위)가 동시에 작업을 수행
> 각 스레드가 자신이 속한 프로세스내의 stack영역을 제외한 메모리를 공유함(메모리 간 데이터 공유가 쉬움)
> 스레드 하나에 문제가 생기면 전체 프로세스에 영향을 끼치기 때문에 시스템 마비 등 결함 가능성 존재(신뢰성 낮음)
> 스레드 간 자원 공유 문제가 발생할 가능성이 있음
